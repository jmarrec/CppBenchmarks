#include <benchmark/benchmark.h>

#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <fmt/format.h>
#include <fmt/color.h>
#include <boost/regex.hpp>
#include <boost/optional.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/filesystem.hpp>
#include <boost/assert.hpp>

constexpr auto getIddExample() {
    return R"(!IDD_Version 3.2.0
! *****************************************************************************
! HEADER. BLABLABLA
! **************************************************************************

\group OpenStudio Core

OS:Version,
       \unique-object
       \required-object
       \format singleLine
       \min-fields 1
  A1, \field Handle
       \type handle
       \required-field
  A2, \field Version Identifier
       \type alpha
       \default 3.2.0
  A3; \field Prerelease Identifier
       \type alpha

OS:ComponentData,
       \memo Defines the meta-data and contents of a Component, that is, a
       \memo subset of an OpenStudio Model.
       \extensible:1
       \min-fields 7
  A1, \field Handle
       \type handle
       \required-field
  A2, \field Name
       \note This should be the name of the Component as listed in the
       \note Component Library.
       \type alpha
       \required-field
       \reference ComponentNames
  A3, \field UUID
       \note This is a UUID that follows the Component throughout its life,
       \note both in Models and in the Component Library.
       \type alpha
       \required-field
  A4, \field Version UUID
       \note This UUID should be changed whenever the Component is modified.
       \type alpha
       \required-field
  A5, \field Creation Timestamp
       \note Unix timestamp from January 1, 1970 00:00 GMT, in seconds.
       \type integer
  A6, \field Version Timestamp
       \note Unix timestamp from January 1, 1970 00:00 GMT, in seconds.
       \type integer
  A7; \field Name of Object
       \note The first object listed should be the primary object, which
       \note indicates the overall Component type.
       \type object-list
       \required-field
       \begin-extensible
       \object-list AllObjects

\group OpenStudio Simulation

OS:ConvergenceLimits,
       \unique-object
       \min-fields 1
  A1, \field Handle
       \type handle
       \required-field
  N1, \field Minimum System Timestep
       \note 0 sets the minimum to the zone timestep (ref: Timestep)
       \note 1 is normal (ratchet down to 1 minute)
       \note setting greater than zone timestep (in minutes) will effectively set to zone timestep
       \type integer
       \units minutes
       \minimum 0
       \maximum 60
  N2, \field Maximum HVAC Iterations
       \type integer
       \minimum 1
       \default 20
  N3, \field Minimum Plant Iterations
       \note Controls the minimum number of plant system solver iterations within a single HVAC iteration
       \note Larger values will increase runtime but might improve solution accuracy for complicated plant systems
       \note Complex plants include: several interconnected loops, heat recovery, thermal load following generators, etc.
       \type integer
       \minimum 1
       \default 2
  N4; \field Maximum Plant Iterations
       \note Controls the maximum number of plant system solver iterations within a single HVAC iteration
       \note Smaller values might decrease runtime but could decrease solution accuracy for complicated plant systems
       \type integer
       \minimum 2
       \default 8

    )";
}

class IddFile_Impl {
  public:
    /// Parse file text to populate this IddFile.
    void parse(std::istream& is);

    // Scans the file quickly to populate m_version, m_header, and count the number of objects
    // Will rewind the stream back to the end of the header, and returns [endHeaderLineNumber, numObjects]
    std::pair<size_t, size_t> scanNumberOfObjectsAndGetHeader(std::istream& is);

    void parseNewWithPreScan(std::istream& is);



    void parseNew2(std::istream& is);

    /// Version string required to be at top of any IddFile.
    std::string m_version;

    /// Build string which might be at the top of an IddFile
    std::string m_build;

    /// The first comment block in an IddFile is its header.
    std::string m_header;

    /// The vector of IddObjects that constitute this IddFile.
    std::vector<std::string> m_objects;

    /// Cache the Version IddObject
    mutable boost::optional<std::string> m_versionObject;
};

namespace iddRegex {
      /// text of the comment only object automatically added to the idd
  const std::string& commentOnlyObjectText() {
    static const std::string result("CommentOnly; ! Autogenerated comment only object.");
    return result;
  }

  /// Search for IDD version in line
  /// matches[1], version identifier
  const boost::regex& version() {
    static const boost::regex result("^!IDD_Version (\\S+)");
    return result;
  }

  /// Search for IDD build in line
  /// matches[1], build identifier
  const boost::regex& build() {
    static const boost::regex result("^!IDD_BUILD (\\S+)");
    return result;
  }

  /// Search for IDD header, each line must start with '!', no preceding whitespace
  /// matches[1], header
  //const boost::regex& header() {
    //static const boost::regex result("^(^!.*?^[^!])");
    //return result;
  //}

  /// Match comment only line
  /// matches[1], comment
  const boost::regex& commentOnlyLine() {
    static const boost::regex result("^[\\s\\t]*[!](.*)");
    return result;
  }

  /// Match group identifier
  /// matches[1], group name
  const boost::regex& group() {
    static const boost::regex result("^[\\\\][gG]roup(.*)");
    return result;
  }

  const boost::regex& line() {
    static const boost::regex result("^([^!]*?)[,;](.*)");
    return result;
  }

  const boost::regex& objectNoFields() {
    static const boost::regex result("^([^!^,]*?)[;](.*)");
    return result;
  }

  /// Match the closing field in an idd object
  /// matches[1], all previous text
  /// matches[2], the last field
  const boost::regex& closingField() {
    static const boost::regex result("(.*)([AN][0-9]+[\\s\\t]*[;].*?)$");
    return result;
  }

  /// Match a field or object level comment
  /// matches[1], after '\' until next '\'
  /// matches[2], after second '\' (may be empty)
  const boost::regex& metaDataComment() {
    static const boost::regex result("^[\\s\\t]*?[\\\\]([^\\\\]*)(.*)");
    return result;
  }

}

std::pair<size_t, size_t> IddFile_Impl::scanNumberOfObjectsAndGetHeader(std::istream& is) {

  // Will save and return the position for the end of the header so we don't have to scan it twice
  std::iostream::pos_type end_header;
  size_t endHeaderLineNum = 0;

  // keep track of line number in the idd (for debugging purposes really...)
  int lineNum = 0;

  // number of object in the idd, 1 is first object
  size_t objectNum = 0;


  // stream for header
  std::stringstream header;

  // temp string to read file
  std::string line;

  // this will contain matches to regular expressions
  boost::smatch matches;

  // For debug
  // boost::atomic_int tid_gen(0);

  // read in the version from the first line
  getline(is, line);
  // fmt::print("First line = {}\n", line);

  if (boost::regex_search(line, matches, iddRegex::version())) {
    m_version = std::string(matches[1].first, matches[1].second);
    // fmt::print(fmt::fg(fmt::color::azure), "m_version={}\n", m_version);
    // this line belongs to the header
    header << line << '\n';

  } else {
    // idd file must have a version on the first line of input
    std::cerr << "Idd file does not contain version on first line: '" << line << "'\n.";
  }

  // read the rest of the file line by line
  // todo, do this by regex

  // have we read the entire header yet
  bool headerClosed = false;
  while (!headerClosed) {

    getline(is, line);

    // fmt::print(fmt::fg(fmt::color::gray), ">>> {}, headerClosed={}, {}\n", lineNum, headerClosed, line);
    ++lineNum;

    // remove whitespace
    boost::trim(line);

    if (line.empty()) {
      headerClosed = true;
      // fmt::print("line is empty, headerClosed={}\n", headerClosed);

      // empty line
      continue;
    } else if (boost::regex_search(line, matches, iddRegex::build())) {
      m_build = std::string(matches[1].first, matches[1].second);
      // fmt::print("m_build={}\n", m_build);
      // this line belongs to the header
      header << line << '\n';

    } else if (boost::regex_match(line, iddRegex::commentOnlyLine())) {
      // fmt::print("commentOnlyLine\n");
      if (!headerClosed) {
        header << line << '\n';
      }

      // comment only line
      continue;
    } else if (boost::regex_search(line, matches, iddRegex::group())) {
      headerClosed = true;
      // fmt::print(fmt::fg(fmt::color::orange_red), "group!, headerClosed={}\n", headerClosed);
      continue;
    } else {
      headerClosed = true;
      // fmt::print(fmt::fg(fmt::color::orange_red), "else!, headerClosed={}\n", headerClosed);
    }
  }

  end_header = is.tellg();
  endHeaderLineNum = lineNum;

  // Now count the number of objects
  while (getline(is, line)) {

    ++lineNum;
    // remove whitespace
    boost::trim(line);

    if (line.empty() || boost::regex_match(line, iddRegex::commentOnlyLine()) || (boost::regex_search(line, matches, iddRegex::group()))) {
      // fmt::print(fmt::fg(fmt::color::green_yellow), ">>> Skip {}, {}\n", lineNum, line);
      continue;
    }

    //int beginLineNum(lineNum);
    bool foundClosingLine(false);

    // a valid idd object to parse
    ++objectNum;

    // fmt::print(fmt::fg(fmt::color::green_yellow), "Entering object {}\n", objectNum);

    // check if the object has no fields
    if (boost::regex_match(line, iddRegex::objectNoFields())) {
      foundClosingLine = true;
      // fmt::print(fmt::fg(fmt::color::dark_orange), "closingField!\n");
    }

    // check if the object has fields, and last field on this line
    if (boost::regex_match(line, iddRegex::closingField())) {
      foundClosingLine = true;
      // fmt::print(fmt::fg(fmt::color::dark_orange), "closingField!\n");
    }

    // continue reading until we have seen the entire object
    // last line will be thrown away, requires empty line between objects in idd
    while (getline(is, line)) {
      // fmt::print(fmt::fg(fmt::color::dark_gray), ">>> {}, {}\n", lineNum, line);
      ++lineNum;

      // remove whitespace
      boost::trim(line);

      // found last field and this is not a field comment
      if (foundClosingLine && (!boost::regex_match(line, iddRegex::metaDataComment()))) {
        // fmt::print(fmt::fg(fmt::color::red), "!metaDataComment : BREAK");
        break;
      }

      if (!line.empty()) {
        // check if we have found the last field
        if (boost::regex_match(line, iddRegex::closingField())) {
          foundClosingLine = true;
          // fmt::print(fmt::fg(fmt::color::lime_green), "closingField!\n");
        }
      }
    }
  }

  // set header
  m_header = header.str();


  // Rewind the stream back to the end of the header
  is.clear();
  is.seekg(end_header, std::ios::beg);

  return std::make_pair(endHeaderLineNum, objectNum);
}


void IddFile_Impl::parseNewWithPreScan(std::istream& is) {

  // keep track of line number in the idd
  int lineNum = 0;

  // number of object in the idd, 1 is first object
  int objectNum = 0;

  // stream for header
  std::stringstream header;

  // have we read the entire header yet
  std::string currentGroup = "";

  // temp string to read file
  std::string line;

  // this will contain matches to regular expressions
  boost::smatch matches;

  auto [endHeaderLineNum, numObjects] = scanNumberOfObjectsAndGetHeader(is);
  // fmt::print(fmt::fg(fmt::color::indian_red) | fmt::emphasis::bold, "\n\nendHeaderLineNum={}, numObjects={}\n", endHeaderLineNum, numObjects);

  // Reserve space in the vector to avoid having to resize
  // +1 because we insert a fake Catchall object
  m_objects.reserve(numObjects + 1); // We insert a fake Catchall object

  // fake a comment only object and put it in the object list and object map
  // TODO::
  m_objects.emplace_back("CATCHALL");

  lineNum = endHeaderLineNum;

  while (getline(is, line)) {

    // fmt::print(fmt::fg(fmt::color::gray), ">>> {},{}\n", lineNum, line);
    ++lineNum;

    // remove whitespace
    boost::trim(line);


    if (line.empty() || boost::regex_match(line, iddRegex::commentOnlyLine())) {
      // fmt::print(fmt::fg(fmt::color::green_yellow), ">>> Skip {}, {}\n", lineNum, line);
      continue;
    }

    if (boost::regex_search(line, matches, iddRegex::group())) {

      // get the group name
      std::string groupName(matches[1].first, matches[1].second);
      boost::trim(groupName);

      // set the current group
      currentGroup = groupName;

      // fmt::print(fmt::fg(fmt::color::orange_red), "group!, currentGroup={}\n", currentGroup);
      continue;
    }

    // Ok, there is an object to parse now!


    //int beginLineNum(lineNum);
    bool foundClosingLine(false);

    // a valid idd object to parse
    ++objectNum;

    // peek at the object name for indexing in map
    std::string objectName;
    if (boost::regex_search(line, matches, iddRegex::line())) {
      objectName = std::string(matches[1].first, matches[1].second);
      boost::trim(objectName);
    } else {
      // can't figure out the object's name
      std::cerr << "Cannot determine object name on line " << lineNum << ": '" << line << "'\n.";
    }

    // fmt::print(fmt::fg(fmt::color::green_yellow), "Entering object {}, objectName={}\n", objectNum, objectName);

    // put the text for this object in a new string
    std::string text(line);

    // check if the object has no fields
    if (boost::regex_match(line, iddRegex::objectNoFields())) {
      foundClosingLine = true;
      // fmt::print(fmt::fg(fmt::color::dark_orange), "closingField!\n");
    }

    // check if the object has fields, and last field on this line
    if (boost::regex_match(line, iddRegex::closingField())) {
      foundClosingLine = true;
      // fmt::print(fmt::fg(fmt::color::dark_orange), "closingField!\n");
    }

    // continue reading until we have seen the entire object
    // last line will be thrown away, requires empty line between objects in idd
    while (getline(is, line)) {
      // fmt::print(fmt::fg(fmt::color::dark_gray), ">>> {}, {}\n", lineNum, line);
      ++lineNum;

      // remove whitespace
      boost::trim(line);

      // found last field and this is not a field comment
      if (foundClosingLine && (!boost::regex_match(line, iddRegex::metaDataComment()))) {
        // fmt::print(fmt::fg(fmt::color::red), "!metaDataComment : BREAK");
        break;
      }

      if (!line.empty()) {
        // if the line is not empty add it to the text
        // note, text does not include newlines
        text += line;

        // check if we have found the last field
        if (boost::regex_match(line, iddRegex::closingField())) {
          foundClosingLine = true;
          // fmt::print(fmt::fg(fmt::color::lime_green), "closingField!\n");
        }
      }
    }

    this->m_objects.push_back(text);
  }
}

void IddFile_Impl::parse(std::istream& is) {

  // keep track of line number in the idd
  int lineNum = 0;

  // number of object in the idd, 1 is first object
  int objectNum = 0;

  // stream for header
  std::stringstream header;

  // have we read the entire header yet
  bool headerClosed = false;

  std::string currentGroup = "";

  // fake a comment only object and put it in the object list and object map
  // TODO::
  m_objects.emplace_back("CATCHALL");

  // temp string to read file
  std::string line;

  // this will contain matches to regular expressions
  boost::smatch matches;

  // For debug
  // boost::atomic_int tid_gen(0);

  // read in the version from the first line
  getline(is, line);
  // fmt::print("First line = {}\n", line);

  if (boost::regex_search(line, matches, iddRegex::version())) {

    m_version = std::string(matches[1].first, matches[1].second);
    // fmt::print(fmt::fg(fmt::color::azure), "m_version={}\n", m_version);
    // this line belongs to the header
    header << line << '\n';

  } else {
    // idd file must have a version on the first line of input
    std::cerr << "Idd file does not contain version on first line: '" << line << "'\n.";
  }

  // read the rest of the file line by line
  // todo, do this by regex
  while (getline(is, line)) {
    // fmt::print(fmt::fg(fmt::color::gray), ">>> {}, headerClosed={}, {}\n", lineNum, headerClosed, line);
    ++lineNum;

    // remove whitespace
    boost::trim(line);

    if (line.empty()) {
      headerClosed = true;
      // fmt::print("line is empty, headerClosed={}\n", headerClosed);

      // empty line
      continue;
    } else if (boost::regex_search(line, matches, iddRegex::build())) {
      m_build = std::string(matches[1].first, matches[1].second);
      // fmt::print("m_build={}\n", m_build);
      // this line belongs to the header
      header << line << '\n';

    } else if (boost::regex_match(line, iddRegex::commentOnlyLine())) {
      // fmt::print("commentOnlyLine\n");
      if (!headerClosed) {
        header << line << '\n';
      }

      // comment only line
      continue;
    } else if (boost::regex_search(line, matches, iddRegex::group())) {

      headerClosed = true;

      // get the group name
      std::string groupName(matches[1].first, matches[1].second);
      boost::trim(groupName);

      // set the current group
      currentGroup = groupName;

      // fmt::print(fmt::fg(fmt::color::orange_red), "group!, headerClosed={}, currentGroup={}\n", headerClosed, currentGroup);


      continue;
    } else {

      headerClosed = true;

      // fmt::print("none of the above, , headerClosed={}\n", headerClosed);

      //int beginLineNum(lineNum);
      bool foundClosingLine(false);

      // a valid idd object to parse
      ++objectNum;

      // peek at the object name for indexing in map
      std::string objectName;
      if (boost::regex_search(line, matches, iddRegex::line())) {
        objectName = std::string(matches[1].first, matches[1].second);
        boost::trim(objectName);
      } else {
        // can't figure out the object's name
        std::cerr << "Cannot determine object name on line " << lineNum << ": '" << line << "'\n.";
      }

      // fmt::print(fmt::fg(fmt::color::green_yellow), "Entering object {}, objectName={}\n", objectNum, objectName);


      // put the text for this object in a new string
      std::string text(line);

      // check if the object has no fields
      if (boost::regex_match(line, iddRegex::objectNoFields())) {
        foundClosingLine = true;
        // fmt::print(fmt::fg(fmt::color::dark_orange), "closingField!\n");
      }

      // check if the object has fields, and last field on this line
      if (boost::regex_match(line, iddRegex::closingField())) {
        foundClosingLine = true;
        // fmt::print(fmt::fg(fmt::color::dark_orange), "closingField!\n");
      }

      // continue reading until we have seen the entire object
      // last line will be thrown away, requires empty line between objects in idd
      while (getline(is, line)) {
        // fmt::print(fmt::fg(fmt::color::dark_gray), ">>> {}, {}\n", lineNum, line);
        ++lineNum;

        // remove whitespace
        boost::trim(line);

        // found last field and this is not a field comment
        if (foundClosingLine && (!boost::regex_match(line, iddRegex::metaDataComment()))) {
          // fmt::print(fmt::fg(fmt::color::red), "!metaDataComment : BREAK");
          break;
        }

        if (!line.empty()) {
          // if the line is not empty add it to the text
          // note, text does not include newlines
          text += line;

          // check if we have found the last field
          if (boost::regex_match(line, iddRegex::closingField())) {
            foundClosingLine = true;
            // fmt::print(fmt::fg(fmt::color::lime_green), "closingField!\n");
          }
        }
      }

      this->m_objects.push_back(text);

    }
  }

  // set header
  m_header = header.str();
}

void IddFile_Impl::parseNew2(std::istream& is) {

  // keep track of line number in the idd
  int lineNum = 0;

  // number of object in the idd, 1 is first object
  int objectNum = 0;

  // stream for header
  std::stringstream header;

  // have we read the entire header yet
  bool headerClosed = false;

  std::string currentGroup = "";

  // fake a comment only object and put it in the object list and object map
  // TODO::
  m_objects.emplace_back("CATCHALL");

  // temp string to read file
  std::string line;

  // this will contain matches to regular expressions
  boost::smatch matches;

  // For debug
  // boost::atomic_int tid_gen(0);

  // read in the version from the first line
  getline(is, line);
  // fmt::print("First line = {}\n", line);

  if (boost::regex_search(line, matches, iddRegex::version())) {

    m_version = std::string(matches[1].first, matches[1].second);
    // fmt::print(fmt::fg(fmt::color::azure), "m_version={}\n", m_version);
    // this line belongs to the header
    header << line << '\n';

  } else {
    // idd file must have a version on the first line of input
    std::cerr << "Idd file does not contain version on first line: '" << line << "'\n.";
  }

  // read the rest of the file line by line
  // todo, do this by regex
  while (!headerClosed) {
    getline(is, line);
    // fmt::print(fmt::fg(fmt::color::gray), ">>> {}, headerClosed={}, {}\n", lineNum, headerClosed, line);
    ++lineNum;

    // remove whitespace
    boost::trim(line);

    if (line.empty()) {
      headerClosed = true;
      // fmt::print("line is empty, headerClosed={}\n", headerClosed);

      // empty line
      continue;

    // This is pointless, we enforce IDD_BUILD to be the first line...
    // } else if (boost::regex_search(line, matches, iddRegex::build())) {

    // We trimmed the line, and we know the line isn't empty, so just check if the first char is a '!' instead of using a regex
    // } else if (boost::regex_match(line, iddRegex::commentOnlyLine())) {
    } else if (line[0] == '!') {
      // fmt::print("commentOnlyLine\n");
      if (!headerClosed) {
        header << line << '\n';
      }

      // comment only line
      continue;
    } else if (boost::regex_search(line, matches, iddRegex::group())) {

      headerClosed = true;

      // get the group name
      std::string groupName(matches[1].first, matches[1].second);
      boost::trim(groupName);

      // set the current group
      currentGroup = groupName;

      // fmt::print(fmt::fg(fmt::color::orange_red), "group!, headerClosed={}, currentGroup={}\n", headerClosed, currentGroup);


      continue;
    } else {

      headerClosed = true;
    }
  }

  // set header
  m_header = header.str();

  while (getline(is, line)) {

    // fmt::print(fmt::fg(fmt::color::gray), ">>> {},{}\n", lineNum, line);
    ++lineNum;

    // remove whitespace
    boost::trim(line);


    if (line.empty() || boost::regex_match(line, iddRegex::commentOnlyLine())) {
      // fmt::print(fmt::fg(fmt::color::green_yellow), ">>> Skip {}, {}\n", lineNum, line);
      continue;
    }

    if (boost::regex_search(line, matches, iddRegex::group())) {

      // get the group name
      std::string groupName(matches[1].first, matches[1].second);
      boost::trim(groupName);

      // set the current group
      currentGroup = groupName;

      // fmt::print(fmt::fg(fmt::color::orange_red), "group!, currentGroup={}\n", currentGroup);
      continue;
    }
    // fmt::print("none of the above, , headerClosed={}\n", headerClosed);

    //int beginLineNum(lineNum);
    bool foundClosingLine(false);

    // a valid idd object to parse
    ++objectNum;

    // peek at the object name for indexing in map
    std::string objectName;
    if (boost::regex_search(line, matches, iddRegex::line())) {
      objectName = std::string(matches[1].first, matches[1].second);
      boost::trim(objectName);
    } else {
      // can't figure out the object's name
      std::cerr << "Cannot determine object name on line " << lineNum << ": '" << line << "'\n.";
    }

    // fmt::print(fmt::fg(fmt::color::green_yellow), "Entering object {}, objectName={}\n", objectNum, objectName);


    // put the text for this object in a new string
    std::string text(line);

    // check if the object has no fields
    if (boost::regex_match(line, iddRegex::objectNoFields())) {
      foundClosingLine = true;
      // fmt::print(fmt::fg(fmt::color::dark_orange), "closingField!\n");
    }

    // check if the object has fields, and last field on this line
    if (boost::regex_match(line, iddRegex::closingField())) {
      foundClosingLine = true;
      // fmt::print(fmt::fg(fmt::color::dark_orange), "closingField!\n");
    }

    // continue reading until we have seen the entire object
    // last line will be thrown away, requires empty line between objects in idd
    while (getline(is, line)) {
      // fmt::print(fmt::fg(fmt::color::dark_gray), ">>> {}, {}\n", lineNum, line);
      ++lineNum;

      // remove whitespace
      boost::trim(line);

      // found last field and this is not a field comment
      if (foundClosingLine && (!boost::regex_match(line, iddRegex::metaDataComment()))) {
        // fmt::print(fmt::fg(fmt::color::red), "!metaDataComment : BREAK");
        break;
      }

      if (!line.empty()) {
        // if the line is not empty add it to the text
        // note, text does not include newlines
        text += line;

        // check if we have found the last field
        if (boost::regex_match(line, iddRegex::closingField())) {
          foundClosingLine = true;
          // fmt::print(fmt::fg(fmt::color::lime_green), "closingField!\n");
        }
      }
    }

    this->m_objects.push_back(text);
  }
}

/*
int main() {

    // std::stringstream is(getIddExample());


    // auto [end_header_pos, endHeaderLineNum, numObjects] = iddFile.scanNumberOfObjectsAndGetHeader(ss);
    // // fmt::print("end_header_pos={}, endHeaderLineNum={}, numObjects={}\n", endHeaderLineNum, end_header_pos, numObjects);


    {
      boost::filesystem::ifstream is("/home/julien/Software/Others/OpenStudio/resources/model/OpenStudio.idd");
      IddFile_Impl iddFile;
      iddFile.parse(is);
      std::cout << "Old parse: " << iddFile.m_objects.size() << '\n';
    }

    {
      boost::filesystem::ifstream is("/home/julien/Software/Others/OpenStudio/resources/model/OpenStudio.idd");
      IddFile_Impl iddFile;
      iddFile.parseNewWithPreScan(is);
      std::cout << "parseNewWithPreScan: " << iddFile.m_objects.size() << '\n';
    }

    {
      boost::filesystem::ifstream is("/home/julien/Software/Others/OpenStudio/resources/model/OpenStudio.idd");
      IddFile_Impl iddFile;
      iddFile.parseNew2(is);
      std::cout << "parseNew2: " << iddFile.m_objects.size() << '\n';
    }

    // for (auto& obj: iddFile.m_objects) {
    //  std::cout << obj << '\n';
    // }
    // fmt::print("iddFile.m_version={}, iddFile.m_header={}\n", iddFile.m_version, iddFile.m_header);

    std::cout << std::flush;

    return 0;
}
*/

static void BM_Current(benchmark::State& state) {
  for (auto _ : state) {
    boost::filesystem::ifstream is("/home/julien/Software/Others/OpenStudio/resources/model/OpenStudio.idd");
    // std::stringstream is(getIddExample());
    IddFile_Impl iddFile;
    iddFile.parse(is);
    // BOOST_ASSERT(iddFile.m_objects.size() == 510);
  }
}

// Register the function as a benchmark
BENCHMARK(BM_Current);

static void BM_New(benchmark::State& state) {
  for (auto _ : state) {
    boost::filesystem::ifstream is("/home/julien/Software/Others/OpenStudio/resources/model/OpenStudio.idd");
    // std::stringstream is(getIddExample());
    IddFile_Impl iddFile;
    iddFile.parseNewWithPreScan(is);
    // BOOST_ASSERT(iddFile.m_objects.size() == 510);
  }
}
// Register the function as a benchmark
BENCHMARK(BM_New);


static void BM_New2(benchmark::State& state) {
  for (auto _ : state) {
    boost::filesystem::ifstream is("/home/julien/Software/Others/OpenStudio/resources/model/OpenStudio.idd");
    // std::stringstream is(getIddExample());
    IddFile_Impl iddFile;
    iddFile.parseNew2(is);
    // BOOST_ASSERT(iddFile.m_objects.size() == 510);
  }
}
// Register the function as a benchmark
BENCHMARK(BM_New2);

// Run the benchmark
BENCHMARK_MAIN();
